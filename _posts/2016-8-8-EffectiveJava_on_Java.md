---
layout: post
category: Java
title: Effective Java  
tagline: by Pigbrain
tags: [Java]
---

<!--more-->

# 객체의 생성과 삭제  
  
### 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라  
	public static Boolean valueOf(boolean b) {
		return b ? Boolean.TRUE : Boolean:FALSE;
	}

* 클래스에 public으로 선언된 정적 팩터리 메서드를 추가하여 객체를 생성하는데는 다음과 같은 장점이 있다  
	* 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다  
	* 생성자와는 달리 호출할 대마다 새로운 객체를 생성할 필요는 없다  
	* 생성자와는 달리 리턴 자료형의 하위 자료형 객체를 반환할 수 있다  
	* 형인자 자료형(parameterized type)객체를 만들때 편리하다   
		* 정적 팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다  
  
	<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule1_1.png" alt="">  
  
* 정적팩터리 메서드만 있는 클래스를 만들게 되면 다음과 같인 문제가 발생한다  
	* public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다  
	* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다  
		* API문서를 보면 생성자는 다른 메서드와 뚜렷이 구별되지만 정적 팩터리 메서드는 그렇지 않다  
		* Example
			* valueOf : 인자로 주어진 값과 같은 값을 갖는 객체를 반환한다  
			* of : valueOf를 간단하게 쓴 것  
			* getInstance : 인자에 기술된 객체를 리턴하지만 인자와 같은 값을 갖지 않을 수도 있다  
			* newInstance: getInstance와 동일하지만 호출할 때마다 다른 객체를 반환한다  
			* getType : getInstance와 같지만 반환될 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을때 사용한다. Type은 팩터리 메서드가 반환할 객체의 자료형이다  
			* newType : newInstance와 같지만 반활된 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을 때 사용한다. Type은 팩터리 메서드가 반환할 객체의 자료형이다  
  

### 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라  
  
### 규칙3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라  
* 원소가 하나뿐인 enum자료형은 싱글턴을 구현하는 가장 좋은 방법이다  
  
### 규칙4 객체 생성을 막을 때는 private 생성자를 사용하라  
  
### 규칙5 불필요한 객체는 만들지 말라  
* 객체 표현형 대신 기본 자료형을 사용하고 예상치 못한 자동 객체화가 발생하지 않도록 유의해야한다  
* 객체를 만들어서 코드의 명확성과 단순성을 높이고 프로그램의 능력을 향상시킬 수 있다면 만드는 것이 좋다  
* 객체 풀(Object Pool)을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다  
  
### 규칙6 유효기간이 지난 객체 참조는 페기하라  
* 객체 참조를 null 처리하는 것은 규범이라기보단 예외적인 조치가 되어야 한다  
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다  
	* 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문에 캐시도 메모리 누수가 흔히 발생하는 장소다  
		* WeakHashMap을 이용하여 해결 가능  
  
### 규칙7 종료자(finalizer) 사용을 피하라  
* 종료자는 즉시 실행되리라는 보장이 전혀 없다  
* 종료자 실행시점은 GC 알고리즘에 좌우되는데 이 알고리즘은 JVM 구현마다 크게 다르다  
	* 종료자 실행시점에 의존하는 프로그램은 JVM마다 다르게 동작한다  
* 종료자를 사용하면 프로그램 성능이 심각하게 덜어진다  
  
<br>  
  
# 모든 객체의 공통 메서드  
  
### 규칙8 equals를 재정의할 때는 일반 규약을 따르라  
* 모든 객체는 오직 자기 자신하고만 같고 아래 조건들 중 하나라도 만족되면 equals를 재정의하지 않아도 된다  
	* 각각의 객체가 고유하다  
	* 클래스에 "논리적 동일성" 검사 방법이 있건 없건 상관없다  
	* 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기에도 적당하다  
	* 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없다  
* equals를 재정의하는 것이 바람직한 경우는 다음과 같다  
	* 논리적 동일성의 개념을 지원하는 클래스인 경우  
	* 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못하는 경우  
* equals를 정의할 때 준수해야하는 일반 규약음 다음과 같다  
	* equals 메서드는 동치관계를 구현한다  
		* 반사성(reflexive) : null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다  
		* 대칭성(symmetric) : null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일때만 true를 반환한다  
		* 추이성(transitive) : null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true다  
		* 일관성(consistent) : 정보에 아무 변화가 없다면 x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다  
		* null이 아닌 참조 x에 대해서 x.equals(null)은 항상 false이다  
* equals 메서드를 구현하기 위해 따라야하는 지침들은 다음과 같다  
	* ==연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라  
	* instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라  
	* equals의 인자를 정확한 자료형으로 변환하라  
	* 중요 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다  
	* 너무 머리 쓰지 마라  
	* equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라  
  
### 규칙9 equals를 재정의할 때는 반드시 hashCode도 재정의하라  
* equals 메서드를 재정의하는 클래스가 hashCode 메서드를 재정의 하지 않을 경우 Object.hashCode의 일반 규약을 어기게 되므로, HashMap, HashSet, Hashtable 같은 Hash기반 컬렉션이 오작동하게 된다  
* 같은 객체는 같은 해시 코드 값을 가져야 하지만 hashCode를 재정의 하지 않으면 이 규칙을 위반 할 수 있다  
  
### 규칙10 toString은 항상 재정의하라  
* 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다  
* toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에 어떤 의도인지는 문서에 분명하게 남겨야 한다  
* toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해 가져올 수 있도록하라  
  
### 규칙11 clone을 재정의할 때는 신중하라  
* Cloneable은 객체가 복재를 허용한다는 사실을 알리는데 사용하려고 만들어진 mixin 인터페이스다  
	* Cloneable 인터페이스에는 clone 메소드가 없으며 Object의 clone 메서드는 protected로 선언되어 있다  
	* 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다  
* clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시켜선 안되며 복사본의 불변식도 만족시켜야 한다  
  
### 규칙12 Comparable 구현을 고려하라  
  
<br>  
  
  
# 클래스와 인터페이스  
  
### 규칙13 클래스와 멤버의 접근 권한은 최소화하라  
* 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들라  
* private, package-private 멤버들은 클래스의 구현 세부사항이며 공개 API의 일부가 아니지만, Serializable을 구현하는 클래스의 멤버라면 공개 API속으로 포함되어 나갈 수도 있다  
* 객체 필드는 절대로 public으로 선언하면 안 된다  
* 변경가능 public 필드를 가진 클래스는 멀티 쓰레드에 안전하지 않다  
  
### 규칙14 public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라  
* package-private 클래스나 private 중첩 클래스는 데이터 필드를 공개하더라도 잘못이라 말할 수 없다  
	* 접근자 메서드보다는 시각적으로 깔끔해 보인다  
	* private 중첩 클래스의 경우 그 클래스의 바깥 클래스 외부의 코드는 아무 영향도 받지 않을 것이다  
  
### 규칙15 변경 가능성을 최소화하라  
* 변경 가능성을 최소화하는 것이 설계하기 쉽고 구현하기 쉽고 오류 가능성도 적고 안전하다  
* 변경 불가능 클래스를 만드는 규칙  
	* 객체 상태를 변경하는 메서드를 제공하지 않는다  
	* 계승(상속)할 수 없도록 한다(클래스를 final로 선언한다)  
	* 모든 필드를 final로 선언한다  
	* 모든 필드를 private로 선언한다  
	* 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다  
		* 클래스에 포함된 변경가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야 한다  
* 변경 불가능 객체는 어떤 동기화도 필요없으며 쓰레드에 안전하다  
* 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다  
	* 객체 생성 비용이 높을 가능성이 있다. 이것을 해결하기 위해 다음 두가지 방법을 사용한다  
		* 자주 요구되는 연산에 대해서는 기본 연산(primitive)으로 제공한다  
		* 변경 가능한 public 동료 클래스를 제공한다  
			* String 클래스의 변경 가능 동료 클래스는 StringBuilder가 될 수 있다  
  
### 규칙16 계승하는 대신 구성하라  
* 메서드 호출과 달리 계승은 캡슐화 원칙을 위반한다  
	* 하위 클래스가 정상 동작하기 위해서는 상위 클래스의 구현에 의존할 수 밖에 없다  
	* 상위 클래스가 수정됨에 다라 하위 클래스 코드는 수정된 적이 없어도 망가질 수 있다  
  
### 규칙17 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라  
* 재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남겨야 한다  
* 효율적인 하위 클래스를 작성할 수 있도록 하려면 클래스 내부 동작에 개입할 수 있는 훅(hooks)을 신중하게 고른 protected메서드 형태로 제공해야 한다  
* 생성자에서는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안 된다  
	* 상위 클래스 생성자는 하위 클래스 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드는 하위 클래스 생성자가 실행되기 전에 호출될 것이다  
* 계승을 위해 설계하는 클래스에서 Cloneable이나 Serializable을 구현하기로 결정했다면 clone이나 readObject 메서드도 생성자와 비슷하게 동작하므로 위 규칙을 따라야한다  
	* readObject메서드 안에서 재정의 가능 메서드를 호출하게 되면 하위 클래스 객체의 상태가 완전이 역직렬화(deserialize)되기 전에 해당 메서드가 실행되어 버린다  
	* clone 메서드의 경우라면 하위 클래스의 clone메서드가 복사본 객체의 상태를 미처 수정하기도 전에 해당 메서드가 실행되어 버릴 것이다  
  
### 규칙18 추상 클래스 대신 인터페이스를 사용하라  
* 인터페이스는 믹스인(mixin)을 정의하는 데 이상적이다  
	* 믹스인은 클래스가 주 자료형(primitive type)이외에 추가로 구현할 수 있는 자료형이다  
* 추상 골격 구현(abstract skeletal implementatoin) 클래스를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합할 수 있다  
	* 인터페이스로는 자료형을 정의하고 구현하는 일은 골격 구현 클래스에 맡기면 된다  
	* 관습적으로 골격 구현 클래스의 이름은 Abstract*Interface*와 같이 정한다  
		* *Interface*는 해당 클래스가 구현하는 인터페이스의 이름이다  
* 추상 클래스로 정의하면 인터페이스보다 나은 점이 한 가지 있는데 인터페이스보다는 추상 클래스가 발전시키기 쉽다는 것이다  
	* 추상 클래스는 기본 구현 코드를 담은 메서드를 언제든 추가 할 수 있다  
* 인터페이스가 공개되고 널리 구현된 다음에는 인터페이스 수정이 거의 불가능하기 때문에 신중히 설계해야한다  
  
### 규칙19 인터페이스는 자료형을 정의할 때만 사용하라  
  
### 규칙20 태그 달린 클래스 대신 클래스 계층을 활용하라  
* 태그가 달린 클래스란 예를들어 특정 변수의 값에 따라 원을 표현할 수도있고 사각형을 표현할 수도 있는 클래스를 말한다  
  
### 규칙21 전략을 표현하고 싶을 때는 함수 객체를 사용하라  
* 가지고 있는 메서드가 하나 뿐인 객체를 함수 객체라고 부른다  
* 실행 가능 전략이 한 번만 사용되는 경우에는 보통 익명 클래스 객체로 구현하고 반복적으로 사용된다면 private static 멤버 클래스로 전략을 표현한 다음 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공객하는 것이 바람직하다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule21_1.png" alt="">  
  
### 규칙22 멤버 클래스는 가능하면 static으로 선언하라  
* 중첩 클래스는 해당 클래스가 속한 클래스 안에서만 사용되며 그렇지 않을 경우 중첩 클래스로 만들면 안 된다  
* 중첩 클래스는 네 가지 종류가 있다  
	* 정적 멤버 클래스(static member class)  
		* 다른 클래스 안에 선언된 일반 클래스  
		* 바깥 클래스의 모든 멤버에(private 까지도) 접근할 수 있다  
		* 정적 멤버 클래스는 바깥 클래스의 정적 멤버이며 다른 정적 멤버와 동일한 접근 권한 규칙을 따른다  
		* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 정적 멤버 클래스로 만들자  
	* 비-정적 멤버 클래스(nonstatic member class)  
		* 바깥 클래스 객체와 자동적으로 연결된다  
		* 비-정적 멤버 클래스 안에서는 바깥 클래스의 메서드를 호출할 수도 있고 this 구문을 통해 바깥 객체에 대한 참조를 획득할 수도 있다  
		* 바깥 클래스 객체 없이는 존재할 수 없다  
		* 비-정적 멤버 클래스 객체는 바깥 클래스 객체와 연결을 위한 공간이 필요하며 이 때문에 객체 생성 시간이 늘어난다  
		* 비-정적 멤버 클래스는 내부적으로 바깥 객체에 대한 참조를 유지하기 때문에 바깥 객체에 대한 GC처리가 힘들어진다  
	* 익명 클래스(anoynhymous class)  
	* 지역 클래스(local class)  
  
<br>  
  
# 제네릭  
  
### 규칙23 새 코드에는 무인자 제네릭 자료형을 사용하지 마라  
* 무인자 자료형을 쓰면 형 안전성이 사라지고 제네릭의 장점 중 하나인 표현력 측면에서 손해를 보게 된다  
* List와 같은 무인자 자료형을 사용하면 형 안정성을 잃게 되지만 List<Object\>와 같은 형인자 자료형을 쓰면 그렇지 않다  
	* List를 인자로 받는 메서드에는 List<String\>을 인자로 전달 할 수 있지만 List<Object\>를 받는 메서드에 List<String\>을 인자로 넘길 수는 없다  
	* 제네릭에 대한 하위 자료형 정의 규칙을 따르면 List<String\>은 List의 하위 자료형이지만 List<Object\>의 하위 자료형은 아니기 때문이
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule23_1.png" alt="">  
  
* Collection<?\>에는 null 이외의 어떤 원소도 넣을 수 없다  
	* null 이외의 어떤 원소도 넣을 수 없을 뿐 아니라 어떤 자료형의 객체를 꺼낼 수 있는지도 알 수 없다  
* 제네릭 자료형 정보는 프로그램이 실행될 때는 지워지기때문에 다음 경우에는 무인자 자료형을 써야한다  
	* 클래스 리터럴에는 반드시 무인자 자료형을 사용해야 한다  
		* List.class, String[].class, int.class 는 가능  
		* List<String\>.class, List<?\>.class는 불가능  
	* 제네릭 자료형에 instanceof 연산자를 적용할 때는 무인자 자료형을 쓰는 것이 좋다  
		* instanceof 연산자는 비한정적 와일드카드 자료형 이외의 형인자 자료형에 적용할 수 없다  
		* 비한정적 와일드카드 자료형을 쓴다고해서 instanceof 연산자가 다르게 동작하는게 아니다. 따라서 <?\>를 붙여봐야 코드만 지저분해질 뿐이다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule23_2.png" alt="">  
  
  
### 규칙24 무점검 경고(unchecked warning)를 제거하라  
* 제거할 수 없는 경고메세지는 형 안정성이 확식할 때만 @SuppressWarnings("unchecked") 어노테이션을 사용해라  
* SupressWarning 어노테이션은 가능한 한 작은 범위에 적용하라  
	* 변수 선언, 아주 짧은 메서드 또는 생성자에 붙인다  
* @SuppressWarnings("unchecked") 어노테이션을 사용할 때마다 왜 형 안정성을 위반하지 않는지 밝히는 주석을 반드시 붙여라  
  
### 규칙25 배열 대신 리스트를 써라  
  
### 규칙26 가능하면 제네릭 자료형으로 만들 것  
  
### 규칙27 가능하면 제네릭 메서드로 만들 것  
  
### 규칙28 한정적 와일드카드를 써서 API 유연성을 높여라  
  
### 규칙29 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라  
  
  
<br>  
  
# 열거형(enum)과 어노테이션  
  
### 규칙30 int 상수 대신 enum을 사용하라  
  
### 규칙31 ordinal 대신 객체 필드를 사용하라  
  
### 규칙32 비트 필드(bit field)대신 EnumSet을 사용하라  
  
### 규칙33 ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라  
  
### 규칙34 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라  
  
### 규칙35 작명 패턴 대신 어노테이션을 사용하라  
  
### 규칙36 Override 어노테이션은 일관되게 사용하라  
  
### 규칙37 자료형을 정의할 때 표식 인터페이스를 사용하라  
  
  
<br>  
  
# 메서드  
  
### 규칙38 인자의 유효성을 검사하라  
  
### 규칙39 필요하다면 방어적 복사본을 만들라  
  
### 규칙40 메서드 시그니처는 신중하게 설계하라  
  
### 규칙41 오버로딩할 때는 주의하라  
  
### 규칙42 varargs는 신중히 사용하라  
  
### 규칙43 null 대신 빈 배열이나 컬렉션을 반환하라  
  
### 규칙44 모든 API 요소에 문서화 주석을 달라  
  
  
<br>  
  
# 책  
* http://book.naver.com/bookdb/book_detail.nhn?bid=8064518  
