---
layout: post
category: Java
title: Effective Java  
tagline: by Pigbrain
tags: [Java]
---

<!--more-->

# 객체의 생성과 삭제  
  
### 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라  
	public static Boolean valueOf(boolean b) {
		return b ? Boolean.TRUE : Boolean:FALSE;
	}

* 클래스에 public으로 선언된 정적 팩터리 메서드를 추가하여 객체를 생성하는데는 다음과 같은 장점이 있다  
	* 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다  
	* 생성자와는 달리 호출할 대마다 새로운 객체를 생성할 필요는 없다  
	* 생성자와는 달리 리턴 자료형의 하위 자료형 객체를 반환할 수 있다  
	* 형인자 자료형(parameterized type)객체를 만들때 편리하다   
		* 정적 팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다  
  
	<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule1_1.png" alt="">  
  
* 정적팩터리 메서드만 있는 클래스를 만들게 되면 다음과 같인 문제가 발생한다  
	* public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다  
	* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다  
		* API문서를 보면 생성자는 다른 메서드와 뚜렷이 구별되지만 정적 팩터리 메서드는 그렇지 않다  
		* Example
			* valueOf : 인자로 주어진 값과 같은 값을 갖는 객체를 반환한다  
			* of : valueOf를 간단하게 쓴 것  
			* getInstance : 인자에 기술된 객체를 리턴하지만 인자와 같은 값을 갖지 않을 수도 있다  
			* newInstance: getInstance와 동일하지만 호출할 때마다 다른 객체를 반환한다  
			* getType : getInstance와 같지만 반환될 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을때 사용한다. Type은 팩터리 메서드가 반환할 객체의 자료형이다  
			* newType : newInstance와 같지만 반활된 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을 때 사용한다. Type은 팩터리 메서드가 반환할 객체의 자료형이다  
  

### 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라  
  
### 규칙3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라  
* 원소가 하나뿐인 enum자료형은 싱글턴을 구현하는 가장 좋은 방법이다  
  
### 규칙4 객체 생성을 막을 때는 private 생성자를 사용하라  
  
### 규칙5 불필요한 객체는 만들지 말라  
* 객체 표현형 대신 기본 자료형을 사용하고 예상치 못한 자동 객체화가 발생하지 않도록 유의해야한다  
* 객체를 만들어서 코드의 명확성과 단순성을 높이고 프로그램의 능력을 향상시킬 수 있다면 만드는 것이 좋다  
* 객체 풀(Object Pool)을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다  
  
### 규칙6 유효기간이 지난 객체 참조는 페기하라  
* 객체 참조를 null 처리하는 것은 규범이라기보단 예외적인 조치가 되어야 한다  
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다  
	* 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문에 캐시도 메모리 누수가 흔히 발생하는 장소다  
		* WeakHashMap을 이용하여 해결 가능  
  
### 규칙7 종료자(finalizer) 사용을 피하라  
* 종료자는 즉시 실행되리라는 보장이 전혀 없다  
* 종료자 실행시점은 GC 알고리즘에 좌우되는데 이 알고리즘은 JVM 구현마다 크게 다르다  
	* 종료자 실행시점에 의존하는 프로그램은 JVM마다 다르게 동작한다  
* 종료자를 사용하면 프로그램 성능이 심각하게 덜어진다  
  
<br>  
  
# 모든 객체의 공통 메서드  
  
### 규칙8 equals를 재정의할 때는 일반 규약을 따르라  
* 모든 객체는 오직 자기 자신하고만 같고 아래 조건들 중 하나라도 만족되면 equals를 재정의하지 않아도 된다  
	* 각각의 객체가 고유하다  
	* 클래스에 "논리적 동일성" 검사 방법이 있건 없건 상관없다  
	* 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기에도 적당하다  
	* 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없다  
* equals를 재정의하는 것이 바람직한 경우는 다음과 같다  
	* 논리적 동일성의 개념을 지원하는 클래스인 경우  
	* 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못하는 경우  
* equals를 정의할 때 준수해야하는 일반 규약음 다음과 같다  
	* equals 메서드는 동치관계를 구현한다  
		* 반사성(reflexive) : null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다  
		* 대칭성(symmetric) : null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일때만 true를 반환한다  
		* 추이성(transitive) : null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true다  
		* 일관성(consistent) : 정보에 아무 변화가 없다면 x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다  
		* null이 아닌 참조 x에 대해서 x.equals(null)은 항상 false이다  
* equals 메서드를 구현하기 위해 따라야하는 지침들은 다음과 같다  
	* ==연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라  
	* instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라  
	* equals의 인자를 정확한 자료형으로 변환하라  
	* 중요 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다  
	* 너무 머리 쓰지 마라  
	* equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라  
  
### 규칙9 equals를 재정의할 때는 반드시 hashCode도 재정의하라  
* equals 메서드를 재정의하는 클래스가 hashCode 메서드를 재정의 하지 않을 경우 Object.hashCode의 일반 규약을 어기게 되므로, HashMap, HashSet, Hashtable 같은 Hash기반 컬렉션이 오작동하게 된다  
* 같은 객체는 같은 해시 코드 값을 가져야 하지만 hashCode를 재정의 하지 않으면 이 규칙을 위반 할 수 있다  
  
### 규칙10 toString은 항상 재정의하라  
* 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다  
* toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에 어떤 의도인지는 문서에 분명하게 남겨야 한다  
* toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해 가져올 수 있도록하라  
  
### 규칙11 clone을 재정의할 때는 신중하라  
* Cloneable은 객체가 복재를 허용한다는 사실을 알리는데 사용하려고 만들어진 mixin 인터페이스다  
	* Cloneable 인터페이스에는 clone 메소드가 없으며 Object의 clone 메서드는 protected로 선언되어 있다  
	* 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다  
* clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시켜선 안되며 복사본의 불변식도 만족시켜야 한다  
  
### 규칙12 Comparable 구현을 고려하라  
  
<br>  
  
  
# 클래스와 인터페이스  
  
### 규칙13 클래스와 멤버의 접근 권한은 최소화하라  
* 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들라  
* private, package-private 멤버들은 클래스의 구현 세부사항이며 공개 API의 일부가 아니지만, Serializable을 구현하는 클래스의 멤버라면 공개 API속으로 포함되어 나갈 수도 있다  
* 객체 필드는 절대로 public으로 선언하면 안 된다  
* 변경가능 public 필드를 가진 클래스는 멀티 쓰레드에 안전하지 않다  
  
### 규칙14 public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라  
* package-private 클래스나 private 중첩 클래스는 데이터 필드를 공개하더라도 잘못이라 말할 수 없다  
	* 접근자 메서드보다는 시각적으로 깔끔해 보인다  
	* private 중첩 클래스의 경우 그 클래스의 바깥 클래스 외부의 코드는 아무 영향도 받지 않을 것이다  
  
### 규칙15 변경 가능성을 최소화하라  
* 변경 가능성을 최소화하는 것이 설계하기 쉽고 구현하기 쉽고 오류 가능성도 적고 안전하다  
* 변경 불가능 클래스를 만드는 규칙  
	* 객체 상태를 변경하는 메서드를 제공하지 않는다  
	* 계승(상속)할 수 없도록 한다(클래스를 final로 선언한다)  
	* 모든 필드를 final로 선언한다  
	* 모든 필드를 private로 선언한다  
	* 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다  
		* 클래스에 포함된 변경가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야 한다  
* 변경 불가능 객체는 어떤 동기화도 필요없으며 쓰레드에 안전하다  
* 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다  
	* 객체 생성 비용이 높을 가능성이 있다. 이것을 해결하기 위해 다음 두가지 방법을 사용한다  
		* 자주 요구되는 연산에 대해서는 기본 연산(primitive)으로 제공한다  
		* 변경 가능한 public 동료 클래스를 제공한다  
			* String 클래스의 변경 가능 동료 클래스는 StringBuilder가 될 수 있다  
  
### 규칙16 계승하는 대신 구성하라  
* 메서드 호출과 달리 계승은 캡슐화 원칙을 위반한다  
	* 하위 클래스가 정상 동작하기 위해서는 상위 클래스의 구현에 의존할 수 밖에 없다  
	* 상위 클래스가 수정됨에 다라 하위 클래스 코드는 수정된 적이 없어도 망가질 수 있다  
  
### 규칙17 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라  
* 재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남겨야 한다  
* 효율적인 하위 클래스를 작성할 수 있도록 하려면 클래스 내부 동작에 개입할 수 있는 훅(hooks)을 신중하게 고른 protected메서드 형태로 제공해야 한다  
* 생성자에서는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안 된다  
	* 상위 클래스 생성자는 하위 클래스 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드는 하위 클래스 생성자가 실행되기 전에 호출될 것이다  
* 계승을 위해 설계하는 클래스에서 Cloneable이나 Serializable을 구현하기로 결정했다면 clone이나 readObject 메서드도 생성자와 비슷하게 동작하므로 위 규칙을 따라야한다  
	* readObject메서드 안에서 재정의 가능 메서드를 호출하게 되면 하위 클래스 객체의 상태가 완전이 역직렬화(deserialize)되기 전에 해당 메서드가 실행되어 버린다  
	* clone 메서드의 경우라면 하위 클래스의 clone메서드가 복사본 객체의 상태를 미처 수정하기도 전에 해당 메서드가 실행되어 버릴 것이다  
  
### 규칙18 추상 클래스 대신 인터페이스를 사용하라  
* 인터페이스는 믹스인(mixin)을 정의하는 데 이상적이다  
	* 믹스인은 클래스가 주 자료형(primitive type)이외에 추가로 구현할 수 있는 자료형이다  
* 추상 골격 구현(abstract skeletal implementatoin) 클래스를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합할 수 있다  
	* 인터페이스로는 자료형을 정의하고 구현하는 일은 골격 구현 클래스에 맡기면 된다  
	* 관습적으로 골격 구현 클래스의 이름은 Abstract*Interface*와 같이 정한다  
		* *Interface*는 해당 클래스가 구현하는 인터페이스의 이름이다  
* 추상 클래스로 정의하면 인터페이스보다 나은 점이 한 가지 있는데 인터페이스보다는 추상 클래스가 발전시키기 쉽다는 것이다  
	* 추상 클래스는 기본 구현 코드를 담은 메서드를 언제든 추가 할 수 있다  
* 인터페이스가 공개되고 널리 구현된 다음에는 인터페이스 수정이 거의 불가능하기 때문에 신중히 설계해야한다  
  
### 규칙19 인터페이스는 자료형을 정의할 때만 사용하라  
  
### 규칙20 태그 달린 클래스 대신 클래스 계층을 활용하라  
* 태그가 달린 클래스란 예를들어 특정 변수의 값에 따라 원을 표현할 수도있고 사각형을 표현할 수도 있는 클래스를 말한다  
  
### 규칙21 전략을 표현하고 싶을 때는 함수 객체를 사용하라  
* 가지고 있는 메서드가 하나 뿐인 객체를 함수 객체라고 부른다  
* 실행 가능 전략이 한 번만 사용되는 경우에는 보통 익명 클래스 객체로 구현하고 반복적으로 사용된다면 private static 멤버 클래스로 전략을 표현한 다음 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공객하는 것이 바람직하다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule21_1.png" alt="">  
  
### 규칙22 멤버 클래스는 가능하면 static으로 선언하라  
* 중첩 클래스는 해당 클래스가 속한 클래스 안에서만 사용되며 그렇지 않을 경우 중첩 클래스로 만들면 안 된다  
* 중첩 클래스는 네 가지 종류가 있다  
	* 정적 멤버 클래스(static member class)  
		* 다른 클래스 안에 선언된 일반 클래스  
		* 바깥 클래스의 모든 멤버에(private 까지도) 접근할 수 있다  
		* 정적 멤버 클래스는 바깥 클래스의 정적 멤버이며 다른 정적 멤버와 동일한 접근 권한 규칙을 따른다  
		* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 정적 멤버 클래스로 만들자  
	* 비-정적 멤버 클래스(nonstatic member class)  
		* 바깥 클래스 객체와 자동적으로 연결된다  
		* 비-정적 멤버 클래스 안에서는 바깥 클래스의 메서드를 호출할 수도 있고 this 구문을 통해 바깥 객체에 대한 참조를 획득할 수도 있다  
		* 바깥 클래스 객체 없이는 존재할 수 없다  
		* 비-정적 멤버 클래스 객체는 바깥 클래스 객체와 연결을 위한 공간이 필요하며 이 때문에 객체 생성 시간이 늘어난다  
		* 비-정적 멤버 클래스는 내부적으로 바깥 객체에 대한 참조를 유지하기 때문에 바깥 객체에 대한 GC처리가 힘들어진다  
	* 익명 클래스(anoynhymous class)  
	* 지역 클래스(local class)  
  
<br>  
  
# 제네릭  
  
### 규칙23 새 코드에는 무인자 제네릭 자료형을 사용하지 마라  
* 무인자 자료형을 쓰면 형 안전성이 사라지고 제네릭의 장점 중 하나인 표현력 측면에서 손해를 보게 된다  
* List와 같은 무인자 자료형을 사용하면 형 안정성을 잃게 되지만 List<Object\>와 같은 형인자 자료형을 쓰면 그렇지 않다  
	* List를 인자로 받는 메서드에는 List<String\>을 인자로 전달 할 수 있지만 List<Object\>를 받는 메서드에 List<String\>을 인자로 넘길 수는 없다  
	* 제네릭에 대한 하위 자료형 정의 규칙을 따르면 List<String\>은 List의 하위 자료형이지만 List<Object\>의 하위 자료형은 아니기 때문이
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule23_1.png" alt="">  
  
* Collection<?\>에는 null 이외의 어떤 원소도 넣을 수 없다  
	* null 이외의 어떤 원소도 넣을 수 없을 뿐 아니라 어떤 자료형의 객체를 꺼낼 수 있는지도 알 수 없다  
* 제네릭 자료형 정보는 프로그램이 실행될 때는 지워지기때문에 다음 경우에는 무인자 자료형을 써야한다  
	* 클래스 리터럴에는 반드시 무인자 자료형을 사용해야 한다  
		* List.class, String[].class, int.class 는 가능  
		* List<String\>.class, List<?\>.class는 불가능  
	* 제네릭 자료형에 instanceof 연산자를 적용할 때는 무인자 자료형을 쓰는 것이 좋다  
		* instanceof 연산자는 비한정적 와일드카드 자료형 이외의 형인자 자료형에 적용할 수 없다  
		* 비한정적 와일드카드 자료형을 쓴다고해서 instanceof 연산자가 다르게 동작하는게 아니다. 따라서 <?\>를 붙여봐야 코드만 지저분해질 뿐이다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule23_2.png" alt="">  
  
  
### 규칙24 무점검 경고(unchecked warning)를 제거하라  
* 제거할 수 없는 경고메세지는 형 안정성이 확식할 때만 @SuppressWarnings("unchecked") 어노테이션을 사용해라  
* SupressWarning 어노테이션은 가능한 한 작은 범위에 적용하라  
	* 변수 선언, 아주 짧은 메서드 또는 생성자에 붙인다  
* @SuppressWarnings("unchecked") 어노테이션을 사용할 때마다 왜 형 안정성을 위반하지 않는지 밝히는 주석을 반드시 붙여라  
  
### 규칙25 배열 대신 리스트를 써라  
* 배열은 공변 자료형(covariant)이지만 제네릭은 불변 자료형(invariant)이다  
	* 공변 자료형이란 Sub가 Super의 하위 자료형이라면 Sub[]도 Super[]의 하위 자료형이라는 것이다  
	* 불변 자료형이란 Type1과 Type2가 있을 때, List<Type1\>은 List<Type2\>의 상위 자료형이나 하위 자료형이 될 수 없다는 것이다  
	* 리스트를 사용하면 컴파일 시점에 오류를 알 수 있다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule25_1.png" alt="">  
  
* 배열은 실체화 되는 자료형이지만 제네릭은 컴파일 시점에만 자료형이 적용되고 실행될 때는 자료형이 삭제된다  
	* 제네릭의 자료형이 실행될 때는 삭제되기 때문에 제네릭을 사용하지 않고 작성된 코드와도 연동된다  
	* 배열의 각 원소의 자료형은 실행시간에 결정된다  
* 제네릭 자료형이나 형인자 자료형, 또는 형인자의 배열을 생성하는 것은 문법적으로 허용되지 않는다  
	* new List<E\>[], new List<String\>[], new E[]는 컴파일되지 않는 코드다  
	* 형 안정성이 보장되지 않기때문에 위 구문들이 허용되지 않는다  
* 제네릭 자료형을 varargs 메서드와 함께 사용하면 복잡한 경고 메세지들을 보게 된다  
	* varargs 메서드를 호출할 때마다 varargs 인자들을 담을 배열이 생성되기 때문이다  


### 규칙26 가능하면 제네릭 자료형으로 만들 것  
  
### 규칙27 가능하면 제네릭 메서드로 만들 것  
  
### 규칙28 한정적 와일드카드를 써서 API 유연성을 높여라  
* **PECS** (Produce - Extends, Consumer - Super)  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule28_1.png" alt="">  
  
* 이 Stack 클래스는 Interable src가 가리키는 원소의 자료형이 스택 원소의 자료형과 일치하면 제대로 동작한다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule28_2.png" alt="">  
  
* Integer는 Number의 하위 자료형이지만 제네릭은 불변(invariant)이기 때문에 위 코드는 오류가 발생한다  
* pushAll의 인자 자료형을 "E의 Iterable"이 아니라 "E의 하위 자료형의 Iterable"이라고 명시하면 위 오류를 해결 가능하다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule28_3.png" alt="">  
  
<br>  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule28_4.png" alt="">  
  
* 이 메서드는 컴파일 뿐 아니라 인자로 주어진 컬렉의 원소 자료형이 스택의 원소 자료형과 일치할 때는 완벽히 동작한다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule28_5.png" alt="">  
  
* 위 코드는 Collection<Object\>가 Collection<Number\>의 하위 자료형이 아니라는 오류가 발생한다  
* popAll의 인자 자료형을 "E의 컬렉션"이 아니라 "E의 상위 자료형의 컬렉션"이라고 명시하면 오류를 해결 가능하다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule28_6.png" alt="">  
  
* 반환값에는 와일드카드 자료형을 쓰면 안 된다  
	* 클라이언트 코드 안에도 와일드카드 자료형을 명시해야 하기 때문이다  
  
### 규칙29 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라  
* 자바 1.5부터 Class가 제네릭 클래스가 되었다  
	* String.class의 자료형은 Class<String\>이다  
	* Integer.class의 자료형은 Class<Integer\>이다  
* 아래 Favorite과 같은 클래스를 형 안전 다형성 컨테이너(typesafe heterogeneous container)라 부른다  
	* Favorite 클래스는 형 안정성을 보장한다  
		* String을 요청했는데 Integer를 반환하거나 하지 않는다  
	* Favorite 클래스는 다형성을 갖고 있다  
		* 일반적인 맵과 달리 모든 키의 자료형이 서로 다르다
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule29_1.png" alt="">  
  
<br>  
  
# 열거형(enum)과 어노테이션  
  
### 규칙30 int 상수 대신 enum을 사용하라  
* 일반적으로 enum은 int 상수와 성능 면에서 비등하다  
	* 자료형을 메모리에 올리고 초기화하는 공간적/시간적 비용 때문에 약간 손해를 볼 뿐이다  
  
### 규칙31 ordinal 대신 객체 필드를 사용하라  
* ordinal 값은 enum 필드가 추가되거나 삭제될때마다 변경 될 수 있다  
* enum 상수에 연계되는 값을 ordinal을 사용해 표현하지 마라 
	* 그런 값이 필요하다면 객체 필드에 저장해야 한다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule31_1.png" alt="">  
  
  
### 규칙32 비트 필드(bit field)대신 EnumSet을 사용하라  
* 1 << 0, 1 << 1등 비트 필드로 나타내면 비트 단위 산술 연산을 통해 합집합이나 교집합 등의 집합 연산을 효율적으로 실행할 수 있다  
* EnumSet 클래스는 enum 자료형의 값으로 구성된 집합을 효율적으로 표현 할 수 있다  
* EnumSet 클래스는 내부젝으로 비트 벡터(bit vector)를 사용하며 enum 값 개수가 64개 이하인 경우 long 값 하나만 사용한다  
	* 위 이유로 1 << 0, 1 << 1과 같은 값을 int 자료형에 저장하여 처리하는 것과 필적하는 성능이 나온다  
  
### 규칙33 ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라  
  
### 규칙34 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라  
* 계승 가능 enum 자료형은 만들 수 없지만 인터페이스를 만들고 그 인터페이스를 구현하는 기본 enum 자료형을 만들면 계승 가능 enum자료형을 흉내 낼 수 있다  
  
### 규칙35 작명 패턴 대신 어노테이션을 사용하라  
* 과거 JUnit 테스트 프레임워크를 사용하려면 테스트 메서드 이름을 test로 시작해야 했는데 이러한 것을 작명패턴(naming pattern)이라 한다  
* 작명패턴의 단점은 다음과 같다  
	* 철자를 틀리면 알아채기 어렵다  
	* 특정한 프로그램 요소에만 적용되도록 만들 수 없다  
		* testSafetyMechanisms라는 클래스를 만들었을 경우 JUnit이 이 클래스의 메서드 전부를 자동으로 실행하길 기대하지만 실제는 그렇게 동작하지 않았다  
	* 프로그램 요소에 인자를 전달할 마땅한 방법이 없다  
  
### 규칙36 Override 어노테이션은 일관되게 사용하라  
* 상위 클래스에 선언된 메서드를 재정의할 대는 반드시 선언부에 Override 어노테이션을 붙여야 한다  
* abstract 클래스에서 abstract 메서드를 재정의할 때나 인터페이스를 구현할 때 Override 메서를 붙이지 않아도 된다  
	* 컴파일러가 오류를 발생 시킬 것이다  
* 코드 인스펙션(code inspection)이라는 어노테이션 검사 기능을 갖춘 IDE를 사용할 경우 어노테이션을 일관되게 사용하면 좋다  
	* Override 어노테이션 없이 상위 클래스 메서드를 재정의하면 경고가 발생한다  
	* Override 어노테이션을 일관되게 사용하면 의도치 않게 메서드를 재정의하는 실수를 피할 수 있다  
	* 경고 메세지를 이용하여 실수로 상위 클래스 메서드를 재정의하는 실수도 피할 수 있다  
  
### 규칙37 자료형을 정의할 때 표식 인터페이스를 사용하라  
* 표식 인터페이스(marker interface)는 아무 메서드도 선언하지 않는 인터페이스다  
	* 클래스가 어떤 속성을 만족한다는 사실을 표현하고 싶을때 사용한다  
* 표식 어노테이션과 비교했을 때 표식 인터페이스는 다음과 같은 장점이 있다  
	* 표식 인터페이스는 표식 붙은 클래스가 만드는 객체들이 구현하는 자료형이다  
		* 표식 어노테이션은 자료형이 아니다  
	* 표식 어노테이션보다 적용범위를 좀 더 세밀하게 지정할 수 있다  
		* 어노테이션을 정의할때 ElementType.TYPE으로 지정하면 어던 클래스나 인터페이스에도 적용이 가능하다  
* 표식 어노테이션의 장점은 어노테이션 자료형을 쓰기 시작한 뒤에도 더 많은 정보를 추가할 수 있다는 것이다  
	* 기본값을 갖는 어노테이션 자료형 요소를 더해 나가면 된다  
* 새로운 메서드가 없는 자료형을 정의하고자 한다면 표식 인터페이스를 이용해야 한다  
* 클래스나 인터페이스 이외의 프로그램 요소에 표식을 달아야하고 앞으로 표식에 더 많은 정보를 추가할 가능성이 있다면 표식 어노테이션을 사용해야 한다  
  
  
<br>  
  
# 메서드  
  
### 규칙38 인자의 유효성을 검사하라  
* public 메소드라면 인자 유효성이 위반되었을 경웨 발생하는 예외를 Javadoc의 @throws 태그를 사용해서 문서화하라  
* public이 아닌 메서드라면 개발자가 메서드 호출이 이루어지는 상황을 통제할 수 있으므로 assert 구문을 이용하여 검사하자  
	* java 인터프리터에 -ea 또는 -enableassertions 옵션을 주어야 assert 문이 처리된다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule38_1.png" alt="">  
  
* 생성자는 나중을 위해 보관될 인자의 유효성을 반드시 검사해야 한다  
* 유효성 검사를 실행하는 오버헤드가 너무 크거나 비현실적이고, 계산 과정에서 유효성 검사가 자연스럽게 이루어지는 경우는 유효성 검사를 미리 하지 않아도된다  
* 무조건 인자에 제약을 두는 것이 바람직한 것이 아니다. 메서드는 가능하면 일반적으로 적용될 수 있도록 설계해야 한다  
	* 메서드가 받을 수 있는 인자에 제약이 적으면 적을수록 더 좋다  
  
### 규칙39 필요하다면 방어적 복사본을 만들라  
* 생성자로 전달되는 변경 가능 객체를 반드시 방어적으로 복사해서 사용하라  
* 인자의 유효성을 검사하기 전에 방어적 복사본을 만들어라. 유효성 검사는 복사본에 대해 시행한다  
	* 인자를 검사한 후 복사본이 만들어지기전에 다른 쓰레드가 인자를 변경해 버리는 일을 막기 위함이다  
* 인자로 전달된 객체의 자료형이 계승이 가능한 자료형일 경우(final 클래스가 아닌 경우) 방어적 복사본을 만들 때 clone을 사용해선 않된다  
	* clone 메서드가 반드시 인자 타입의 객체를 반환 할 것이라는 보장이 없다  
		* 공격을 위해 특별히 설계된 하위 클래스 객체가 반환될 수도 있다는 의미이다  
* 내부 필드를 리턴할때는 방어적 복사본을 생성하여 반환하도록한다  
* 복사 오버헤드가 너무 크고 클래스 사용자가 그 내부 컴포넌트를 부적절하게 변경하지 않는다는 보장이 있을 때는 방어적 복사를 하는 대신 클라이언트 측에서 컴포넌트를 변경해서는 안 된다는 것을 문서에 명시하자  
  
### 규칙40 메서드 시그니처는 신중하게 설계하라  
* 메서드 이름은 신중하게 고르라  
* 편리한 메서드를 제공하는 데 너무 열 올리지 마라  
	* 모든 메서드는 맡은 일이 명확하고 거기에 충실해야 한다  
* 인자 리스트를 길게 만들지마라. 4개 이하가 되도록 노력하라  
	* 자료형이 같은 인자들이 길게 연결된 인자 리스트는 특히 더 위험하다  
* 인자의 자료형으로는 클래스보다 인터페이스가 좋다  
* 인자 자료형으로 boolean을 쓰는 것보다는 원소가 2개인 enum자료형을 쓰는 것이 낫다  
	* 좀 더 읽기 편한 코드가 만들어진다  
  
### 규칙41 오버로딩할 때는 주의하라  
* 오버로딩을 사용할 때는 혼란스럽지않게 사용할 수 있도록 주의해야 한다  
	* 혼란을 피하는 안전하고 보수적인 전략은 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 API에 포함시키지 않는 것이다  
  
### 규칙42 varargs는 신중히 사용하라  
* 가변인자(varargs)는 인자 수에 맞는 배열이 자동 생성되고 모든 인자가 해당 배열에 대입된다. 그리고 해당 배열이 메서드에 인자로 전달된다  
* 가변인자는 정말로 임의 개수가 인자를 처리할 수 있는 메서드를 만들어야 할 때만 사용하라  
* 가변인자는 인자 없이 메서드를 호출하는 것이 가능하고 인자의 유효성을 검사하는 코드를 명시적으로 넣어야한다  
	* 메서드가 인자를 두 개 받도록 선언하여 인자 없이 메서드 호출하는 것을 막을 수 있다  
  
<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule42_1.png" alt="">  
  
  
### 규칙43 null 대신 빈 배열이나 컬렉션을 반환하라  
  
### 규칙44 모든 API 요소에 문서화 주석을 달라  
  
  
<br>  
  
# 책  
* http://book.naver.com/bookdb/book_detail.nhn?bid=8064518  
