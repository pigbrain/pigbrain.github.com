---
layout: post
category: Java
title: Effective Java  
tagline: by Pigbrain
tags: [Java]
---

<!--more-->

# 객체의 생성과 삭제  
  
### 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라  
	public static Boolean valueOf(boolean b) {
		return b ? Boolean.TRUE : Boolean:FALSE;
	}

* 클래스에 public으로 선언된 정적 팩터리 메서드를 추가하여 객체를 생성하는데는 다음과 같은 장점이 있다  
	* 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다  
	* 생성자와는 달리 호출할 대마다 새로운 객체를 생성할 필요는 없다  
	* 생성자와는 달리 리턴 자료형의 하위 자료형 객체를 반환할 수 있다  
	* 형인자 자료형(parameterized type)객체를 만들때 편리하다   
		* 정적 팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다  
  
	<img src="/assets/themes/Snail/img/Java/EffectiveJava/rule1_1.png" alt="">  
  
* 정적팩터리 메서드만 있는 클래스를 만들게 되면 다음과 같인 문제가 발생한다  
	* public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다  
	* 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다  
		* API문서를 보면 생성자는 다른 메서드와 뚜렷이 구별되지만 정적 팩터리 메서드는 그렇지 않다  
		* Example
			* valueOf : 인자로 주어진 값과 같은 값을 갖는 객체를 반환한다  
			* of : valueOf를 간단하게 쓴 것  
			* getInstance : 인자에 기술된 객체를 리턴하지만 인자와 같은 값을 갖지 않을 수도 있다  
			* newInstance: getInstance와 동일하지만 호출할 때마다 다른 객체를 반환한다  
			* getType : getInstance와 같지만 반환될 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을때 사용한다. Type은 팩터리 메서드가 반환할 객체의 자료형이다  
			* newType : newInstance와 같지만 반활된 객체의 클래스와 다른 클래스에 팩터리 메서드가 있을 때 사용한다. Type은 팩터리 메서드가 반환할 객체의 자료형이다  
  

### 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라  
  
### 규칙3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라  
* 원소가 하나뿐인 enum자료형은 싱글턴을 구현하는 가장 좋은 방법이다  
  
### 규칙4 객체 생성을 막을 때는 private 생성자를 사용하라  
  
### 규칙5 불필요한 객체는 만들지 말라  
* 객체 표현형 대신 기본 자료형을 사용하고 예상치 못한 자동 객체화가 발생하지 않도록 유의해야한다  
* 객체를 만들어서 코드의 명확성과 단순성을 높이고 프로그램의 능력을 향상시킬 수 있다면 만드는 것이 좋다  
* 객체 풀(Object Pool)을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다  
  
### 규칙6 유효기간이 지난 객체 참조는 페기하라  
* 객체 참조를 null 처리하는 것은 규범이라기보단 예외적인 조치가 되어야 한다  
* 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다  
	* 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문에 캐시도 메모리 누수가 흔히 발생하는 장소다  
		* WeakHashMap을 이용하여 해결 가능  
  
### 규칙7 종료자(finalizer) 사용을 피하라  
* 종료자는 즉시 실행되리라는 보장이 전혀 없다  
* 종료자 실행시점은 GC 알고리즘에 좌우되는데 이 알고리즘은 JVM 구현마다 크게 다르다  
	* 종료자 실행시점에 의존하는 프로그램은 JVM마다 다르게 동작한다  
* 종료자를 사용하면 프로그램 성능이 심각하게 덜어진다  
  
<br>  
  
# 모든 객체의 공통 메서드  
  
### 규칙8 equals를 재정의할 때는 일반 규약을 따르라  
* 모든 객체는 오직 자기 자신하고만 같고 아래 조건들 중 하나라도 만족되면 equals를 재정의하지 않아도 된다  
	* 각각의 객체가 고유하다  
	* 클래스에 "논리적 동일성" 검사 방법이 있건 없건 상관없다  
	* 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기에도 적당하다  
	* 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없다  
* equals를 재정의하는 것이 바람직한 경우는 다음과 같다  
	* 논리적 동일성의 개념을 지원하는 클래스인 경우  
	* 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못하는 경우  
* equals를 정의할 때 준수해야하는 일반 규약음 다음과 같다  
	* equals 메서드는 동치관계를 구현한다  
		* 반사성(reflexive) : null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다  
		* 대칭성(symmetric) : null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일때만 true를 반환한다  
		* 추이성(transitive) : null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true다  
		* 일관성(consistent) : 정보에 아무 변화가 없다면 x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다  
		* null이 아닌 참조 x에 대해서 x.equals(null)은 항상 false이다  
* equals 메서드를 구현하기 위해 따라야하는 지침들은 다음과 같다  
	* ==연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라  
	* instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라  
	* equals의 인자를 정확한 자료형으로 변환하라  
	* 중요 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다  
	* 너무 머리 쓰지 마라  
	* equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라  
  
### 규칙9 equals를 재정의할 때는 반드시 hashCode도 재정의하라  
* equals 메서드를 재정의하는 클래스가 hashCode 메서드를 재정의 하지 않을 경우 Object.hashCode의 일반 규약을 어기게 되므로, HashMap, HashSet, Hashtable 같은 Hash기반 컬렉션이 오작동하게 된다  
* 같은 객체는 같은 해시 코드 값을 가져야 하지만 hashCode를 재정의 하지 않으면 이 규칙을 위반 할 수 있다  
  
### 규칙10 toString은 항상 재정의하라  
* 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다  
* toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에 어떤 의도인지는 문서에 분명하게 남겨야 한다  
* toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해 가져올 수 있도록하라  
  
### 규칙11 clone을 재정의할 때는 신중하라  
* Cloneable은 객체가 복재를 허용한다는 사실을 알리는데 사용하려고 만들어진 mixin 인터페이스다  
	* Cloneable 인터페이스에는 clone 메소드가 없으며 Object의 clone 메서드는 protected로 선언되어 있다  
	* 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다  
* clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시켜선 안되며 복사본의 불변식도 만족시켜야 한다  
  
### 규칙12 Comparable 구현을 고려하라  
  
<br>  
  
  
# 클래스와 인터페이스  
  
### 규칙13 클래스와 멤버의 접근 권한은 최소화하라  
  
### 규칙14 public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라  
  
### 규칙15 변경 가능성을 최소화하라  
  
### 규칙16 계승하는 대신 구성하라  
  
### 규칙17 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라  
  
### 규칙18 추상 클래스 대신 인터페이스를 사용하라  
  
### 규칙19 인터페이스는 자료형을 정의할 때만 사용하라  
  
### 규칙20 태그 달린 클래스 대신 클래스 계층을 활용하라  
  
### 규칙21 전략을 표현하고 싶을 때는 함수 객체를 사용하라  
  
### 규칙22 멤버 클래스는 가능하면 static으로 선언하라  
  
  


# 책  
* http://book.naver.com/bookdb/book_detail.nhn?bid=8064518  
